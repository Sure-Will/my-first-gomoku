<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹ AI å¯¹æˆ˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 800px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .player-info {
            flex: 1;
            text-align: center;
        }

        .player-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .player-timer {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .player-timer.warning {
            color: #ff6b6b;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .current-turn {
            font-size: 1.1em;
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border-radius: 25px;
            font-weight: bold;
        }

        .status {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1em;
            color: #555;
            min-height: 30px;
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #board {
            background: #DEB887;
            border: 3px solid #8B4513;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        button {
            padding: 12px 30px;
            font-size: 1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary {
            background: #f093fb;
            color: white;
        }

        .btn-secondary:hover {
            background: #d77fe8;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .thinking {
            display: inline-block;
            margin-left: 10px;
        }

        .thinking::after {
            content: '...';
            animation: thinking 1.5s infinite;
        }

        @keyframes thinking {
            0% { content: '.'; }
            33% { content: '..'; }
            66% { content: '...'; }
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .game-over-modal {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            animation: modalAppear 0.3s;
        }

        @keyframes modalAppear {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .game-over-modal h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #667eea;
        }

        .game-over-modal p {
            font-size: 1.3em;
            margin-bottom: 30px;
            color: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® äº”å­æ£‹ AI å¯¹æˆ˜</h1>

        <div class="info-panel">
            <div class="player-info">
                <div class="player-name">ğŸ¤– AI (ç™½å­)</div>
                <div class="player-timer" id="ai-timer">5.0s</div>
            </div>
            <div class="current-turn" id="turn-indicator">AI å…ˆæ‰‹</div>
            <div class="player-info">
                <div class="player-name">ğŸ‘¤ ç©å®¶ (é»‘å­)</div>
                <div class="player-timer" id="player-timer">5.0s</div>
            </div>
        </div>

        <div class="status" id="status">AI å°†åœ¨å¤©å…ƒè½å­...</div>

        <div class="board-container">
            <canvas id="board" width="600" height="600"></canvas>
        </div>

        <div class="controls">
            <button class="btn-primary" onclick="game.restart()">ğŸ”„ é‡æ–°å¼€å§‹</button>
            <button class="btn-secondary" onclick="game.undo()">â†¶ æ‚”æ£‹</button>
        </div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-modal">
            <h2 id="gameOverTitle">æ¸¸æˆç»“æŸ</h2>
            <p id="gameOverMessage"></p>
            <button class="btn-primary" onclick="game.restart()">å†æ¥ä¸€å±€</button>
        </div>
    </div>

    <script>
        // äº”å­æ£‹æ¸¸æˆç±»
        class GomokuGame {
            constructor() {
                this.boardSize = 15;
                this.cellSize = 40;
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                this.currentPlayer = 1; // 1: ç™½å­(AI), 2: é»‘å­(ç©å®¶)
                this.gameOver = false;
                this.canvas = document.getElementById('board');
                this.ctx = this.canvas.getContext('2d');
                this.moveHistory = [];
                this.aiThinking = false;
                this.playerStarted = false;

                // è®¡æ—¶å™¨
                this.aiTimeLeft = 5.0;
                this.playerTimeLeft = 5.0;
                this.currentTimer = null;
                this.timerInterval = null;

                this.init();
            }

            init() {
                this.drawBoard();
                this.canvas.addEventListener('click', (e) => this.handleClick(e));

                // AIå…ˆæ‰‹åœ¨å¤©å…ƒ
                setTimeout(() => {
                    const center = Math.floor(this.boardSize / 2);
                    this.makeMove(center, center, 1);
                    this.updateStatus('è½®åˆ°ä½ äº†ï¼Œç‚¹å‡»æ£‹ç›˜ä¸‹é»‘å­');
                    this.updateTurnIndicator();
                }, 500);
            }

            drawBoard() {
                const ctx = this.ctx;
                const size = this.cellSize;

                // èƒŒæ™¯
                ctx.fillStyle = '#DEB887';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ç½‘æ ¼çº¿
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;

                for (let i = 0; i < this.boardSize; i++) {
                    // ç«–çº¿
                    ctx.beginPath();
                    ctx.moveTo(size + i * size, size);
                    ctx.lineTo(size + i * size, size + (this.boardSize - 1) * size);
                    ctx.stroke();

                    // æ¨ªçº¿
                    ctx.beginPath();
                    ctx.moveTo(size, size + i * size);
                    ctx.lineTo(size + (this.boardSize - 1) * size, size + i * size);
                    ctx.stroke();
                }

                // å¤©å…ƒå’Œæ˜Ÿä½
                const stars = [
                    [3, 3], [3, 11], [11, 3], [11, 11], [7, 7]
                ];

                ctx.fillStyle = '#000';
                stars.forEach(([x, y]) => {
                    ctx.beginPath();
                    ctx.arc(size + x * size, size + y * size, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // ç»˜åˆ¶æ£‹å­
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            this.drawStone(i, j, this.board[i][j]);
                        }
                    }
                }

                // æ ‡è®°æœ€åä¸€æ­¥
                if (this.moveHistory.length > 0) {
                    const lastMove = this.moveHistory[this.moveHistory.length - 1];
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(size + lastMove.x * size, size + lastMove.y * size, 12, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            drawStone(x, y, player) {
                const ctx = this.ctx;
                const size = this.cellSize;
                const centerX = size + x * size;
                const centerY = size + y * size;
                const radius = size * 0.4;

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);

                if (player === 1) {
                    // ç™½å­
                    const gradient = ctx.createRadialGradient(
                        centerX - radius * 0.3, centerY - radius * 0.3, radius * 0.1,
                        centerX, centerY, radius
                    );
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(1, '#ddd');
                    ctx.fillStyle = gradient;
                } else {
                    // é»‘å­
                    const gradient = ctx.createRadialGradient(
                        centerX - radius * 0.3, centerY - radius * 0.3, radius * 0.1,
                        centerX, centerY, radius
                    );
                    gradient.addColorStop(0, '#666');
                    gradient.addColorStop(1, '#000');
                    ctx.fillStyle = gradient;
                }

                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            handleClick(e) {
                if (this.gameOver || this.aiThinking || this.currentPlayer !== 2) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = Math.round((e.clientX - rect.left - this.cellSize) / this.cellSize);
                const y = Math.round((e.clientY - rect.top - this.cellSize) / this.cellSize);

                if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize && this.board[x][y] === 0) {
                    this.makeMove(x, y, 2);

                    if (!this.playerStarted) {
                        this.playerStarted = true;
                        this.startTimer(1); // å¼€å§‹AIè®¡æ—¶
                    }

                    if (!this.gameOver) {
                        this.aiMove();
                    }
                }
            }

            makeMove(x, y, player) {
                this.board[x][y] = player;
                this.moveHistory.push({ x, y, player });
                this.drawBoard();

                if (this.checkWin(x, y, player)) {
                    this.endGame(player);
                    return;
                }

                this.currentPlayer = player === 1 ? 2 : 1;
                this.updateTurnIndicator();
            }

            checkWin(x, y, player) {
                const directions = [
                    [[0, 1], [0, -1]],   // æ¨ªå‘
                    [[1, 0], [-1, 0]],   // çºµå‘
                    [[1, 1], [-1, -1]],  // æ–œå‘
                    [[1, -1], [-1, 1]]   // åæ–œå‘
                ];

                for (let dir of directions) {
                    let count = 1;
                    for (let [dx, dy] of dir) {
                        let nx = x + dx;
                        let ny = y + dy;
                        while (nx >= 0 && nx < this.boardSize && ny >= 0 && ny < this.boardSize &&
                               this.board[nx][ny] === player) {
                            count++;
                            nx += dx;
                            ny += dy;
                        }
                    }
                    if (count >= 5) return true;
                }
                return false;
            }

            endGame(winner) {
                this.gameOver = true;
                this.stopTimer();

                const overlay = document.getElementById('gameOverOverlay');
                const title = document.getElementById('gameOverTitle');
                const message = document.getElementById('gameOverMessage');

                if (winner === 1) {
                    title.textContent = 'ğŸ¤– AI è·èƒœï¼';
                    message.textContent = 'AI å¤ªå¼ºäº†ï¼å†æ¥æŒ‘æˆ˜ä¸€æ¬¡ï¼Ÿ';
                } else {
                    title.textContent = 'ğŸ‰ æ­å–œä½ èµ¢äº†ï¼';
                    message.textContent = 'ä½ æˆ˜èƒœäº†å¼ºå¤§çš„ AIï¼';
                }

                overlay.style.display = 'flex';
            }

            // AIç§»åŠ¨
            async aiMove() {
                if (this.gameOver || this.aiThinking) return;

                this.aiThinking = true;
                this.updateStatus('AI æ€è€ƒä¸­<span class="thinking"></span>');
                this.startTimer(1); // AIè®¡æ—¶

                const startTime = Date.now();
                const maxTime = 5000; // 5ç§’

                try {
                    const move = await this.findBestMove(maxTime);

                    // ç¡®ä¿è‡³å°‘æ€è€ƒä¸€ä¼šå„¿ï¼Œè®©ç©å®¶çœ‹åˆ°
                    const elapsed = Date.now() - startTime;
                    if (elapsed < 500) {
                        await new Promise(resolve => setTimeout(resolve, 500 - elapsed));
                    }

                    if (move) {
                        this.makeMove(move.x, move.y, 1);
                        this.updateStatus('è½®åˆ°ä½ äº†');
                        this.startTimer(2); // ç©å®¶è®¡æ—¶
                    }
                } catch (e) {
                    console.error('AI error:', e);
                }

                this.aiThinking = false;
            }

            // æŸ¥æ‰¾æœ€ä½³ç§»åŠ¨ï¼ˆé‡å†™é˜²å®ˆä¼˜å…ˆé€»è¾‘ï¼‰
            async findBestMove(maxTime) {
                const startTime = Date.now();

                // 1. æ£€æŸ¥AIæ˜¯å¦èƒ½ç«‹å³è·èƒœ
                const winMove = this.findWinningMove(1);
                if (winMove) return winMove;

                // 2. ã€å…³é”®ã€‘å¿…é¡»é˜²å®ˆå¯¹æ‰‹çš„äº”è¿
                const blockWin = this.findWinningMove(2);
                if (blockWin) return blockWin;

                // 3. ã€å…³é”®ã€‘å¿…é¡»é˜²å®ˆå¯¹æ‰‹çš„æ´»å››ï¼ˆä¸¤ä¸ªå››è¿ç‚¹ï¼‰
                const blockLiveFour = this.findAllThreats(2);
                const opponentLiveFour = blockLiveFour.filter(m => m.four >= 1);
                if (opponentLiveFour.length > 0) {
                    return opponentLiveFour[0]; // ç«‹å³å µæ´»å››
                }

                // 4. ã€å…³é”®ã€‘å¿…é¡»é˜²å®ˆå¯¹æ‰‹çš„åŒå†²å››
                const opponentDoubleFour = blockLiveFour.filter(m => m.blockFour >= 2);
                if (opponentDoubleFour.length > 0) {
                    return opponentDoubleFour[0];
                }

                // 5. ã€å…³é”®ã€‘å¿…é¡»é˜²å®ˆå¯¹æ‰‹çš„å†²å››
                const opponentBlockFour = blockLiveFour.filter(m => m.blockFour >= 1);
                if (opponentBlockFour.length > 0) {
                    return opponentBlockFour[0];
                }

                // 6. ã€å…³é”®ã€‘å¿…é¡»é˜²å®ˆå¯¹æ‰‹çš„åŒæ´»ä¸‰
                const opponentDoubleThree = blockLiveFour.filter(m => m.three >= 2);
                if (opponentDoubleThree.length > 0) {
                    return opponentDoubleThree[0];
                }

                // 7. ã€å…³é”®ã€‘å¿…é¡»é˜²å®ˆå¯¹æ‰‹çš„æ´»ä¸‰
                const opponentThree = blockLiveFour.filter(m => m.three >= 1);
                if (opponentThree.length > 0) {
                    // å¦‚æœå¯¹æ‰‹æœ‰æ´»ä¸‰ï¼Œä¼˜å…ˆå µ
                    return opponentThree[0];
                }

                // 8. AIå°è¯•å½¢æˆè‡ªå·±çš„å¨èƒ
                const aiThreats = this.findAllThreats(1);

                // æ´»å››
                const aiLiveFour = aiThreats.filter(m => m.four >= 1);
                if (aiLiveFour.length > 0) return aiLiveFour[0];

                // åŒå†²å››
                const aiDoubleFour = aiThreats.filter(m => m.blockFour >= 2);
                if (aiDoubleFour.length > 0) return aiDoubleFour[0];

                // å†²å››+æ´»ä¸‰
                const aiFourThree = aiThreats.filter(m => m.blockFour >= 1 && m.three >= 1);
                if (aiFourThree.length > 0) return aiFourThree[0];

                // åŒæ´»ä¸‰
                const aiDoubleThree = aiThreats.filter(m => m.three >= 2);
                if (aiDoubleThree.length > 0) return aiDoubleThree[0];

                // 9. VCFæœç´¢ - è¿ç»­å†²å››
                if (Date.now() - startTime < maxTime * 0.4) {
                    const vcfMove = this.searchVCF(1, 10);
                    if (vcfMove) return vcfMove;
                }

                // 10. Minimaxæœç´¢
                return this.minimaxSearch(maxTime - (Date.now() - startTime));
            }

            // æŸ¥æ‰¾æ‰€æœ‰å¨èƒç‚¹ï¼ˆæ–°å¢ï¼‰
            findAllThreats(player) {
                const threats = [];
                const moves = this.generateMoves();

                for (let move of moves) {
                    this.board[move.x][move.y] = player;
                    const patterns = this.analyzePoint(move.x, move.y, player);
                    this.board[move.x][move.y] = 0;

                    if (patterns.five || patterns.four || patterns.blockFour || patterns.three) {
                        threats.push({
                            x: move.x,
                            y: move.y,
                            five: patterns.five ? 1 : 0,
                            four: patterns.four || 0,
                            blockFour: patterns.blockFour || 0,
                            three: patterns.three || 0,
                            score: move.score
                        });
                    }
                }

                // æŒ‰å¨èƒç­‰çº§æ’åº
                threats.sort((a, b) => {
                    const scoreA = a.five * 1000000 + a.four * 100000 + a.blockFour * 10000 + a.three * 1000;
                    const scoreB = b.five * 1000000 + b.four * 100000 + b.blockFour * 10000 + b.three * 1000;
                    return scoreB - scoreA;
                });

                return threats;
            }

            // æŸ¥æ‰¾å…³é”®é˜²å®ˆç‚¹ï¼ˆé˜²æ­¢å¯¹æ‰‹åŒæ´»ä¸‰ã€åŒå†²å››ç­‰ï¼‰
            findCriticalDefense(player) {
                const moves = this.generateMoves();

                for (let move of moves) {
                    this.board[move.x][move.y] = player;
                    const patterns = this.analyzePoint(move.x, move.y, player);
                    this.board[move.x][move.y] = 0;

                    // å¦‚æœå¯¹æ‰‹èƒ½å½¢æˆæ´»å››ï¼Œå¿…é¡»é˜²å®ˆ
                    if (patterns.four >= 1) {
                        return move;
                    }

                    // å¦‚æœå¯¹æ‰‹èƒ½å½¢æˆåŒæ´»ä¸‰ï¼Œå¿…é¡»é˜²å®ˆ
                    if (patterns.three >= 2) {
                        return move;
                    }

                    // å¦‚æœå¯¹æ‰‹èƒ½å½¢æˆåŒå†²å››ï¼Œå¿…é¡»é˜²å®ˆ
                    if (patterns.blockFour >= 2) {
                        return move;
                    }

                    // å†²å››+æ´»ä¸‰ä¹Ÿæ˜¯å¿…èƒœ
                    if (patterns.blockFour >= 1 && patterns.three >= 1) {
                        return move;
                    }
                }

                return null;
            }

            // æŸ¥æ‰¾èƒ½å½¢æˆåŒå¨èƒçš„èµ°æ³•
            findDoubleThreatMove(player) {
                const moves = this.generateMoves();

                for (let move of moves) {
                    this.board[move.x][move.y] = player;
                    const patterns = this.analyzePoint(move.x, move.y, player);
                    this.board[move.x][move.y] = 0;

                    // æ´»å››ç›´æ¥èµ¢
                    if (patterns.four >= 1) {
                        return move;
                    }

                    // åŒæ´»ä¸‰æ˜¯å¿…èƒœ
                    if (patterns.three >= 2) {
                        return move;
                    }

                    // åŒå†²å››ä¹Ÿæ˜¯å¿…èƒœ
                    if (patterns.blockFour >= 2) {
                        return move;
                    }

                    // å†²å››+æ´»ä¸‰
                    if (patterns.blockFour >= 1 && patterns.three >= 1) {
                        return move;
                    }
                }

                return null;
            }

            // æŸ¥æ‰¾è·èƒœç§»åŠ¨
            findWinningMove(player) {
                const moves = this.generateMoves();
                for (let move of moves) {
                    this.board[move.x][move.y] = player;
                    const isWin = this.checkWin(move.x, move.y, player);
                    this.board[move.x][move.y] = 0;
                    if (isWin) return move;
                }
                return null;
            }

            // VCFæœç´¢ - è¿ç»­å†²å››
            searchVCF(player, depth) {
                if (depth <= 0) return null;

                const opponent = 3 - player;
                const threats = this.findThreats(player, 4); // æŸ¥æ‰¾å†²å››ç‚¹

                for (let threat of threats) {
                    this.board[threat.x][threat.y] = player;

                    if (this.checkWin(threat.x, threat.y, player)) {
                        this.board[threat.x][threat.y] = 0;
                        return threat;
                    }

                    // å¯¹æ‰‹å¿…é¡»é˜²å®ˆ
                    const defenses = this.findThreats(player, 4);
                    let allDefensesFail = defenses.length > 0;

                    for (let defense of defenses) {
                        this.board[defense.x][defense.y] = opponent;
                        const nextMove = this.searchVCF(player, depth - 1);
                        this.board[defense.x][defense.y] = 0;

                        if (!nextMove) {
                            allDefensesFail = false;
                            break;
                        }
                    }

                    this.board[threat.x][threat.y] = 0;

                    if (allDefensesFail && defenses.length > 0) {
                        return threat;
                    }
                }

                return null;
            }

            // VCTæœç´¢ - è¿ç»­å¨èƒ
            searchVCT(player, depth) {
                if (depth <= 0) return null;

                const opponent = 3 - player;
                const threats = this.findThreats(player, 3); // æŸ¥æ‰¾æ´»ä¸‰å’Œå†²å››

                for (let threat of threats) {
                    this.board[threat.x][threat.y] = player;

                    if (this.checkWin(threat.x, threat.y, player)) {
                        this.board[threat.x][threat.y] = 0;
                        return threat;
                    }

                    const score = this.evaluatePosition(player);
                    if (score > 10000) {
                        this.board[threat.x][threat.y] = 0;
                        return threat;
                    }

                    this.board[threat.x][threat.y] = 0;
                }

                return null;
            }

            // æŸ¥æ‰¾å¨èƒç‚¹
            findThreats(player, minLength) {
                const threats = [];
                const moves = this.generateMoves();

                for (let move of moves) {
                    this.board[move.x][move.y] = player;
                    const patterns = this.analyzePoint(move.x, move.y, player);
                    this.board[move.x][move.y] = 0;

                    if (patterns.four > 0 || patterns.blockFour > 0 ||
                        (minLength <= 3 && patterns.three > 0)) {
                        threats.push({...move, score: patterns.four * 1000 + patterns.blockFour * 100 + patterns.three * 10});
                    }
                }

                threats.sort((a, b) => b.score - a.score);
                return threats.slice(0, 10);
            }

            // åˆ†ææŸä¸ªç‚¹çš„æ£‹å‹
            analyzePoint(x, y, player) {
                const patterns = { five: 0, four: 0, blockFour: 0, three: 0, blockThree: 0, two: 0 };
                const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];

                for (let [dx, dy] of directions) {
                    const line = this.getLine(x, y, dx, dy, player);
                    const pattern = this.analyzePattern(line);

                    if (pattern.five) patterns.five++;
                    else if (pattern.four) patterns.four++;
                    else if (pattern.blockFour) patterns.blockFour++;
                    else if (pattern.three) patterns.three++;
                    else if (pattern.blockThree) patterns.blockThree++;
                    else if (pattern.two) patterns.two++;
                }

                return patterns;
            }

            // è·å–ä¸€æ¡çº¿ä¸Šçš„æ£‹å­
            getLine(x, y, dx, dy, player) {
                const line = [player]; // ä¸­å¿ƒç‚¹

                // æ­£æ–¹å‘
                for (let i = 1; i <= 5; i++) {
                    const nx = x + dx * i;
                    const ny = y + dy * i;
                    if (nx < 0 || nx >= this.boardSize || ny < 0 || ny >= this.boardSize) {
                        line.push(-1);
                        break;
                    }
                    line.push(this.board[nx][ny]);
                }

                // åæ–¹å‘
                for (let i = 1; i <= 5; i++) {
                    const nx = x - dx * i;
                    const ny = y - dy * i;
                    if (nx < 0 || nx >= this.boardSize || ny < 0 || ny >= this.boardSize) {
                        line.unshift(-1);
                        break;
                    }
                    line.unshift(this.board[nx][ny]);
                }

                return line;
            }

            // åˆ†ææ£‹å‹ï¼ˆä¿®å¤ç‰ˆï¼‰
            analyzePattern(line) {
                const center = Math.floor(line.length / 2);
                const player = line[center];
                if (player === 0 || player === -1) return {};

                // å‘ä¸¤è¾¹æ‰©å±•ï¼Œç»Ÿè®¡è¿ç»­çš„æ£‹å­
                let count = 1; // ä¸­å¿ƒç‚¹
                let leftBlock = false;
                let rightBlock = false;

                // å‘å·¦æ‰©å±•
                let i = center - 1;
                while (i >= 0 && line[i] === player) {
                    count++;
                    i--;
                }
                // æ£€æŸ¥å·¦è¾¹æ˜¯å¦è¢«å µ
                if (i < 0 || line[i] === -1 || (line[i] !== 0 && line[i] !== player)) {
                    leftBlock = true;
                }

                // å‘å³æ‰©å±•
                let j = center + 1;
                while (j < line.length && line[j] === player) {
                    count++;
                    j++;
                }
                // æ£€æŸ¥å³è¾¹æ˜¯å¦è¢«å µ
                if (j >= line.length || line[j] === -1 || (line[j] !== 0 && line[j] !== player)) {
                    rightBlock = true;
                }

                const blocked = (leftBlock && rightBlock) ? 2 : (leftBlock || rightBlock) ? 1 : 0;

                // åˆ¤æ–­æ£‹å‹
                if (count >= 5) {
                    return { five: true };
                }

                if (count === 4) {
                    if (blocked === 0) {
                        return { four: true }; // æ´»å››ï¼š_XXXX_
                    } else if (blocked === 1) {
                        return { blockFour: true }; // å†²å››ï¼š#XXXX_ æˆ– _XXXX#
                    }
                }

                if (count === 3) {
                    if (blocked === 0) {
                        return { three: true }; // æ´»ä¸‰ï¼š_XXX_
                    } else if (blocked === 1) {
                        return { blockThree: true }; // çœ ä¸‰
                    }
                }

                if (count === 2) {
                    if (blocked === 0) {
                        return { two: true };
                    }
                }

                return {};
            }

            // Minimaxæœç´¢ï¼ˆå¢å¼ºç‰ˆï¼‰
            minimaxSearch(timeLimit) {
                const startTime = Date.now();
                const moves = this.generateMoves();

                if (moves.length === 0) return null;

                let bestMove = moves[0];
                let bestScore = -Infinity;

                // è¿­ä»£åŠ æ·±æœç´¢ï¼šä»æµ…åˆ°æ·±é€æ­¥æœç´¢
                let currentDepth = 3;
                const maxDepth = 5;

                while (currentDepth <= maxDepth && Date.now() - startTime < timeLimit * 0.8) {
                    let tempBestMove = bestMove;
                    let tempBestScore = -Infinity;

                    // ä¸ºæ¯ä¸ªç§»åŠ¨è¯„åˆ†
                    for (let move of moves.slice(0, 15)) { // è€ƒè™‘å‰15ä¸ªå€™é€‰ç‚¹
                        if (Date.now() - startTime > timeLimit * 0.9) break;

                        this.board[move.x][move.y] = 1;
                        const score = this.minimax(currentDepth, -Infinity, Infinity, false, startTime, timeLimit);
                        this.board[move.x][move.y] = 0;

                        if (score > tempBestScore) {
                            tempBestScore = score;
                            tempBestMove = move;
                        }
                    }

                    if (Date.now() - startTime < timeLimit * 0.9) {
                        bestMove = tempBestMove;
                        bestScore = tempBestScore;
                    }

                    currentDepth++;
                }

                return bestMove;
            }

            minimax(depth, alpha, beta, isMaximizing, startTime, timeLimit) {
                if (depth === 0 || Date.now() - startTime > timeLimit * 0.95) {
                    return this.evaluatePosition(1);
                }

                const moves = this.generateMoves().slice(0, 12); // è€ƒè™‘å‰12ä¸ªå€™é€‰ç‚¹

                if (isMaximizing) {
                    let maxScore = -Infinity;
                    for (let move of moves) {
                        this.board[move.x][move.y] = 1;

                        if (this.checkWin(move.x, move.y, 1)) {
                            this.board[move.x][move.y] = 0;
                            return 100000 + depth * 100; // æ›´æ—©è·èƒœå¾—åˆ†æ›´é«˜
                        }

                        const score = this.minimax(depth - 1, alpha, beta, false, startTime, timeLimit);
                        this.board[move.x][move.y] = 0;

                        maxScore = Math.max(maxScore, score);
                        alpha = Math.max(alpha, score);
                        if (beta <= alpha) break; // Alpha-Betaå‰ªæ
                    }
                    return maxScore;
                } else {
                    let minScore = Infinity;
                    for (let move of moves) {
                        this.board[move.x][move.y] = 2;

                        if (this.checkWin(move.x, move.y, 2)) {
                            this.board[move.x][move.y] = 0;
                            return -100000 - depth * 100; // æ›´æ—©è¾“æ‰æ‰£åˆ†æ›´å¤š
                        }

                        const score = this.minimax(depth - 1, alpha, beta, true, startTime, timeLimit);
                        this.board[move.x][move.y] = 0;

                        minScore = Math.min(minScore, score);
                        beta = Math.min(beta, score);
                        if (beta <= alpha) break; // Alpha-Betaå‰ªæ
                    }
                    return minScore;
                }
            }

            // ç”Ÿæˆå€™é€‰ç§»åŠ¨ï¼ˆä¼˜åŒ–ç‰ˆï¼šåªè€ƒè™‘ä¸´è¿‘ä½ç½®ï¼‰
            generateMoves() {
                const scored = [];
                const visited = new Set();

                // å¦‚æœæ£‹ç›˜ä¸ºç©ºæˆ–åªæœ‰ä¸€ä¸ªå­ï¼Œè¿”å›ä¸­å¿ƒé™„è¿‘çš„ä½ç½®
                let totalPieces = 0;
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] !== 0) totalPieces++;
                    }
                }

                if (totalPieces === 0) {
                    const center = Math.floor(this.boardSize / 2);
                    return [{ x: center, y: center, score: 100 }];
                }

                if (totalPieces === 1) {
                    const center = Math.floor(this.boardSize / 2);
                    const moves = [];
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const x = center + dx;
                            const y = center + dy;
                            if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize && this.board[x][y] === 0) {
                                moves.push({ x, y, score: 50 });
                            }
                        }
                    }
                    return moves;
                }

                // åªè€ƒè™‘å·²æœ‰æ£‹å­å‘¨å›´2æ ¼å†…çš„ç©ºä½
                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] !== 0) {
                            // æ£€æŸ¥å‘¨å›´2æ ¼
                            for (let dx = -2; dx <= 2; dx++) {
                                for (let dy = -2; dy <= 2; dy++) {
                                    const x = i + dx;
                                    const y = j + dy;
                                    const key = `${x},${y}`;

                                    if (x >= 0 && x < this.boardSize &&
                                        y >= 0 && y < this.boardSize &&
                                        this.board[x][y] === 0 &&
                                        !visited.has(key)) {
                                        visited.add(key);
                                        const score = this.evaluateMovePosition(x, y);
                                        scored.push({ x, y, score });
                                    }
                                }
                            }
                        }
                    }
                }

                // æŒ‰åˆ†æ•°æ’åºï¼Œè¿”å›å‰25ä¸ªæœ€ä½³å€™é€‰ç‚¹
                scored.sort((a, b) => b.score - a.score);
                return scored.slice(0, 25);
            }

            hasNeighbor(x, y, distance) {
                for (let i = Math.max(0, x - distance); i <= Math.min(this.boardSize - 1, x + distance); i++) {
                    for (let j = Math.max(0, y - distance); j <= Math.min(this.boardSize - 1, y + distance); j++) {
                        if (this.board[i][j] !== 0) return true;
                    }
                }
                return false;
            }

            evaluateMovePosition(x, y) {
                let score = 0;

                // ä½ç½®æƒé‡ï¼ˆä¸­å¿ƒæ›´æœ‰ä»·å€¼ï¼‰
                const center = Math.floor(this.boardSize / 2);
                const distToCenter = Math.abs(x - center) + Math.abs(y - center);
                score += (15 - distToCenter) * 5; // ä¸­å¿ƒä½ç½®åŠ åˆ†

                // è¯„ä¼°AIçš„å¾—åˆ†
                this.board[x][y] = 1;
                const aiPatterns = this.analyzePoint(x, y, 1);
                score += aiPatterns.five * 100000;
                score += aiPatterns.four * 50000; // æ´»å››éå¸¸é‡è¦
                score += aiPatterns.blockFour * 5000;
                score += aiPatterns.three * 1000; // æ´»ä¸‰å¾ˆé‡è¦
                score += aiPatterns.blockThree * 100;
                score += aiPatterns.two * 50;

                // æ£€æµ‹åŒå¨èƒç»„åˆ
                if (aiPatterns.three >= 2) score += 30000; // åŒæ´»ä¸‰
                if (aiPatterns.blockFour >= 2) score += 25000; // åŒå†²å››
                if (aiPatterns.blockFour >= 1 && aiPatterns.three >= 1) score += 35000; // å†²å››+æ´»ä¸‰

                this.board[x][y] = 0;

                // è¯„ä¼°é˜²å®ˆçš„å¾—åˆ†ï¼ˆé˜²å®ˆæƒé‡ç¨ä½äºè¿›æ”»ï¼‰
                this.board[x][y] = 2;
                const playerPatterns = this.analyzePoint(x, y, 2);
                score += playerPatterns.five * 90000;
                score += playerPatterns.four * 45000;
                score += playerPatterns.blockFour * 4000;
                score += playerPatterns.three * 900;
                score += playerPatterns.blockThree * 90;
                score += playerPatterns.two * 40;

                // æ£€æµ‹å¯¹æ‰‹çš„åŒå¨èƒ
                if (playerPatterns.three >= 2) score += 25000;
                if (playerPatterns.blockFour >= 2) score += 20000;
                if (playerPatterns.blockFour >= 1 && playerPatterns.three >= 1) score += 30000;

                this.board[x][y] = 0;

                return score;
            }

            evaluatePosition(player) {
                let score = 0;
                const opponent = 3 - player;

                // ç»Ÿè®¡æ•´ä½“æ£‹å‹
                let aiLiveFour = 0, aiBlockFour = 0, aiLiveThree = 0;
                let oppLiveFour = 0, oppBlockFour = 0, oppLiveThree = 0;

                for (let i = 0; i < this.boardSize; i++) {
                    for (let j = 0; j < this.boardSize; j++) {
                        if (this.board[i][j] === player) {
                            const patterns = this.analyzePoint(i, j, player);

                            // ä½ç½®ä»·å€¼ï¼ˆä¸­å¿ƒæ›´å¥½ï¼‰
                            const center = Math.floor(this.boardSize / 2);
                            const distToCenter = Math.abs(i - center) + Math.abs(j - center);
                            score += (15 - distToCenter) * 2;

                            // æ£‹å‹å¾—åˆ†
                            score += patterns.five * 100000;
                            score += patterns.four * 15000;
                            score += patterns.blockFour * 1500;
                            score += patterns.three * 400;
                            score += patterns.blockThree * 100;
                            score += patterns.two * 20;

                            aiLiveFour += patterns.four;
                            aiBlockFour += patterns.blockFour;
                            aiLiveThree += patterns.three;

                        } else if (this.board[i][j] === opponent) {
                            const patterns = this.analyzePoint(i, j, opponent);

                            // å¯¹æ‰‹æ£‹å‹æ‰£åˆ†ï¼ˆé˜²å®ˆæƒé‡ï¼‰
                            score -= patterns.five * 100000;
                            score -= patterns.four * 14000;
                            score -= patterns.blockFour * 1400;
                            score -= patterns.three * 380;
                            score -= patterns.blockThree * 95;
                            score -= patterns.two * 18;

                            oppLiveFour += patterns.four;
                            oppBlockFour += patterns.blockFour;
                            oppLiveThree += patterns.three;
                        }
                    }
                }

                // ç»„åˆæ£‹å‹åŠ æˆ
                if (aiLiveThree >= 2) score += 8000; // åŒæ´»ä¸‰
                if (aiBlockFour >= 2) score += 6000; // åŒå†²å››
                if (oppLiveThree >= 2) score -= 7000; // å¯¹æ‰‹åŒæ´»ä¸‰
                if (oppBlockFour >= 2) score -= 5500; // å¯¹æ‰‹åŒå†²å››

                return score;
            }

            // è®¡æ—¶å™¨ç›¸å…³
            startTimer(player) {
                this.stopTimer();
                this.currentTimer = player;

                if (player === 1) {
                    this.aiTimeLeft = 5.0;
                } else {
                    this.playerTimeLeft = 5.0;
                }

                this.updateTimerDisplay();

                this.timerInterval = setInterval(() => {
                    if (player === 1) {
                        this.aiTimeLeft -= 0.1;
                        if (this.aiTimeLeft <= 0) {
                            this.aiTimeLeft = 0;
                            this.handleTimeout(1);
                        }
                    } else {
                        this.playerTimeLeft -= 0.1;
                        if (this.playerTimeLeft <= 0) {
                            this.playerTimeLeft = 0;
                            this.handleTimeout(2);
                        }
                    }
                    this.updateTimerDisplay();
                }, 100);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                this.currentTimer = null;
            }

            updateTimerDisplay() {
                const aiTimer = document.getElementById('ai-timer');
                const playerTimer = document.getElementById('player-timer');

                aiTimer.textContent = this.aiTimeLeft.toFixed(1) + 's';
                playerTimer.textContent = this.playerTimeLeft.toFixed(1) + 's';

                // æ·»åŠ è­¦å‘Šæ ·å¼
                if (this.aiTimeLeft <= 2) {
                    aiTimer.classList.add('warning');
                } else {
                    aiTimer.classList.remove('warning');
                }

                if (this.playerTimeLeft <= 2) {
                    playerTimer.classList.add('warning');
                } else {
                    playerTimer.classList.remove('warning');
                }
            }

            handleTimeout(player) {
                this.stopTimer();

                if (player === 2) {
                    // ç©å®¶è¶…æ—¶ï¼Œéšæœºä¸‹ä¸€æ­¥
                    const validMoves = [];
                    for (let i = 0; i < this.boardSize; i++) {
                        for (let j = 0; j < this.boardSize; j++) {
                            if (this.board[i][j] === 0 && this.hasNeighbor(i, j, 2)) {
                                validMoves.push({ x: i, y: j });
                            }
                        }
                    }

                    if (validMoves.length > 0) {
                        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                        this.updateStatus('è¶…æ—¶ï¼ç³»ç»Ÿéšæœºä¸ºä½ ä¸‹äº†ä¸€æ­¥');

                        setTimeout(() => {
                            this.makeMove(randomMove.x, randomMove.y, 2);
                            if (!this.playerStarted) {
                                this.playerStarted = true;
                            }
                            if (!this.gameOver) {
                                this.aiMove();
                            }
                        }, 500);
                    }
                }
            }

            updateStatus(message) {
                document.getElementById('status').innerHTML = message;
            }

            updateTurnIndicator() {
                const indicator = document.getElementById('turn-indicator');
                if (this.currentPlayer === 1) {
                    indicator.textContent = 'AI å›åˆ';
                    indicator.style.background = '#667eea';
                } else {
                    indicator.textContent = 'ç©å®¶å›åˆ';
                    indicator.style.background = '#f093fb';
                }
            }

            undo() {
                if (this.moveHistory.length < 2 || this.aiThinking || this.gameOver) return;

                // æ’¤é”€ç©å®¶å’ŒAIçš„æœ€åä¸¤æ­¥
                this.moveHistory.pop();
                this.moveHistory.pop();

                // é‡å»ºæ£‹ç›˜
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                for (let move of this.moveHistory) {
                    this.board[move.x][move.y] = move.player;
                }

                this.currentPlayer = 2;
                this.drawBoard();
                this.updateStatus('å·²æ‚”æ£‹ï¼Œè½®åˆ°ä½ äº†');
                this.updateTurnIndicator();

                // é‡ç½®è®¡æ—¶å™¨
                this.stopTimer();
                if (this.playerStarted) {
                    this.startTimer(2);
                }
            }

            restart() {
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(0));
                this.moveHistory = [];
                this.currentPlayer = 1;
                this.gameOver = false;
                this.aiThinking = false;
                this.playerStarted = false;
                this.stopTimer();

                this.aiTimeLeft = 5.0;
                this.playerTimeLeft = 5.0;
                this.updateTimerDisplay();

                document.getElementById('gameOverOverlay').style.display = 'none';
                this.drawBoard();
                this.updateStatus('AI å°†åœ¨å¤©å…ƒè½å­...');
                this.updateTurnIndicator();

                // AIå…ˆæ‰‹
                setTimeout(() => {
                    const center = Math.floor(this.boardSize / 2);
                    this.makeMove(center, center, 1);
                    this.updateStatus('è½®åˆ°ä½ äº†ï¼Œç‚¹å‡»æ£‹ç›˜ä¸‹é»‘å­');
                }, 500);
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        let game;
        window.addEventListener('load', () => {
            game = new GomokuGame();
        });
    </script>
</body>
</html>
